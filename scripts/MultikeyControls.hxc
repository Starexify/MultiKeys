import funkin.graphics.FunkinCamera;
import funkin.graphics.FunkinSprite;
import funkin.graphics.shaders.HSVShader;
import funkin.modding.base.ScriptedFlxSubState;
import funkin.save.Save;
import funkin.ui.AtlasText;
import funkin.ui.ButtonStyle;
import funkin.ui.MenuTypedList;
import funkin.ui.NavControls;
import funkin.ui.Prompt;
import funkin.ui.TextMenuItem;
import funkin.ui.TextMenuList;
import funkin.ui.WrapMode;
import funkin.ui.options.OptionsState;
import funkin.util.InputUtil;

import flixel.FlxG;
import flixel.FlxObject;

class MultikeyControls extends ScriptedFlxSubState {
    var multikeysOptions:Null<MultikeySaveData> = Save.instance.modOptions.get("multikeys");
    var mkHooks:MultikeyHooks;

    var itemGroups = [];
    var labels = [];
    var headers = [];

    var camFollow:FlxObject;
    var menuCamera:FunkinCamera;
    var controlGrid:MenuTypedList;
    var keyUsedToEnterPrompt;
    var canExit = true;
    var prompt;

    var CONTROL_BASE_X = 50;
    var CONTROL_MARGIN_X = 700;
    var CONTROL_SPACING_X = 300;

    var prevPersistentUpdate:Bool;

    function new() {
        super();

        prevPersistentUpdate = FlxG.state.persistentUpdate;
        FlxG.state.persistentUpdate = false;

        mkHooks = new MultikeyHooks();

        menuCamera = new FunkinCamera('controlsMenu');
        FlxG.cameras.add(menuCamera, false);
        menuCamera.bgColor = 0x0;
        camera = menuCamera;

        controlGrid = new MenuTypedList(NavControls.Columns(2), WrapMode.Vertical);
        add(controlGrid);

        var menuBG = new FunkinSprite().loadGraphic(Paths.image('menuBG'));
        var hsv = new HSVShader(-0.6, 0.9, 3.6);
        menuBG.shader = hsv;
        menuBG.setGraphicSize(Std.int(menuBG.width * 1.1));
        menuBG.updateHitbox();
        menuBG.screenCenter();
        menuBG.scrollFactor.set(0, 0);
        add(menuBG);


        var y = 30;
        var spacer = 70;

        var notesHeader = new AtlasText(0, y, "NOTES", "bold").screenCenter(0x01);
        add(notesHeader);
        y += spacer;

        for (i in 0...mkHooks.DIRECTIONS.length) {
            if (i != 3) {
                var header = new AtlasText(0, y, (i + 1) + " KEY", "default").screenCenter(0x01);
                y += spacer;
                add(header);
                headers.push(header);

                for (key in 0...(i + 1)) {
                    //trace(i + "key" + key);
                    var label = new AtlasText(CONTROL_BASE_X, y, mkHooks.NOTE_DIRECTION_NAMES[i][key], "bold");
                    add(label);
                    labels.push(label);

                    var controls = multikeysOptions.controls[i][key];
                    var controlsArray = [InputUtil.getKeyName(controls[0]), InputUtil.getKeyName(controls[1])];
                    for (index in 0...controlsArray.length) {
                        if (controls[index] == 0) controlsArray[index] = "---";
                    }

                    for (column in 0...2) {
                        var item = new TextMenuItem(label.x + CONTROL_MARGIN_X + column * CONTROL_SPACING_X, y, controlsArray[column], "default", () -> selectBind(i, key, column));
                        item.fireInstantly = true;
                        itemGroups.push(item);
                        add(item);
                        controlGrid.addItem(i + "key" + key + column, item);
                    }

                    y += spacer;
                }
            }

        }

        camFollow = new FlxObject(FlxG.width / 2, 0, 70, 70);
        menuCamera.follow(camFollow, null, 0.06);

        var margin = 100;
        var _this = menuCamera.deadzone;
        var x = 0;
        var y = margin;
        var width = menuCamera.width;
        var height = menuCamera.height - margin * 2;
        if (height == null) height = 0;
        if (width == null) width = 0;
        if (y == null) y = 0;
        if (x == null) x = 0;
        _this.x = x;
        _this.y = y;
        _this.width = width;
        _this.height = height;
        menuCamera.minScrollY = 0;

        controlGrid.onChange.add(selected -> {
            camFollow.y = selected.y;
            for (label in labels) label.alpha = 0.6;
            labels[controlGrid.selectedIndex / 2].alpha = 1.0;
        });

        prompt = new Prompt("\nPress any key to rebind\n\n\nBackspace to unbind\n    Escape to cancel", ButtonStyle.None);
        prompt.create();
        prompt.createBgFromMargin(100, -328339);
        prompt.back.scrollFactor.set(0, 0);
        prompt.exists = false;
        add(prompt);
    }

    override function update(elapsed:Float) {
        if (prompt.exists) {
            var key = FlxG.keys.firstJustReleased();
            if (key != -1 && key != keyUsedToEnterPrompt) {
                if (key == 27) {
                    closePrompt();
                } else if (key == 8) {
                    onInputSelect(0);
                    closePrompt();
                } else {
                    onInputSelect(key);
                    closePrompt();
                }
            }
        }

        if (FlxG.keys.justPressed.ESCAPE && canExit) FlxG.switchState(() -> new OptionsState());

        super.update(elapsed);
    }

    function onInputSelect(input) {
        var newControlName = InputUtil.getKeyName(input);
        if (input == 0)
            newControlName = "---";
        controlGrid.members[controlGrid.selectedIndex].label.text = newControlName;

        multikeysOptions.controls[selectedKC][selectedNoteIndex][selectedControl] = input;
    }

    var selectedKC = -1;
    var selectedNoteIndex = -1;
    var selectedControl = -1;

    function selectBind(kc, note, controlNum) {
        selectedKC = kc;
        selectedNoteIndex = note;
        selectedControl = controlNum;
        keyUsedToEnterPrompt = FlxG.keys.firstJustPressed();
        controlGrid.enabled = false;
        canExit = false;
        prompt.exists = true;
    }

    // Cleanup
    override function close() {
        cleanup();
        super.close();
    }

    override function destroy() {
        cleanup();
        super.destroy();
    }


    function cleanup() {
        if (FlxG.cameras.list.indexOf(this.menuCamera) != -1) FlxG.cameras.remove(this.menuCamera);
        FlxG.state.persistentUpdate = prevPersistentUpdate;
    }

    function closePrompt() {
        prompt.exists = false;
        controlGrid.enabled = true;
        canExit = true;
    }
}