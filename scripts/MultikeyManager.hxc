import funkin.PlayerSettings;
import funkin.data.song.importer.FNFLegacyImporter;
import funkin.input.Control;
import funkin.input.Controls;
import funkin.input.PreciseInputManager;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ScriptedModule;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.play.notes.NoteSprite;
import funkin.play.notes.Strumline;
import funkin.ui.debug.charting.ChartEditorState;
import funkin.ui.debug.charting.handlers.ChartEditorThemeHandler;

import flixel.FlxG;
import flixel.input.FlxInput;
import flixel.math.FlxMath;

import Lambda;

class MultikeyManager extends ScriptedModule {
    var NOTE_GAPS = [112, 112, 112, 112, 112, 105, 85, 80, 70, 65];
    var NOTE_SCALES = [1, 1, 1, 1, 1, 0.95, 0.9, 0.85, 0.8, 0.75];
    var NOTE_DIRECTIONS:Array<Array<Int>> = [
        [2],
        [0, 3],
        [0, 2, 3],
        [0, 1, 2, 3],
        [0, 1, 2, 2, 3],
        [0, 2, 3, 0, 1, 3],
        [0, 2, 3, 2, 0, 1, 3],
        [0, 1, 2, 3, 0, 1, 2, 3],
        [0, 1, 2, 3, 2, 0, 1, 2, 3],
    ];

    var DIRECTIONS:Array<Int> = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

    var state:PlayState;
    var playerStrumline:Strumline;
    var inputPressQueue:Array<PreciseInputEvent> = [];
    var inputReleaseQueue:Array<PreciseInputEvent> = [];

    function new() {
        super("MultikeyManager", FlxMath.MIN_VALUE_INT);
    }

    function onStateChange(state) {
        if (Std.isOfType(state, PlayState)) setupMultikey();
    }

    override function onStateChangeBegin(event:StateChangeScriptEvent) {
        FlxG.signals.preStateCreate.addOnce(onStateChange);
    }

    override function onSubStateOpenBegin(event:SubStateScriptEvent) {
        if (!Std.isOfType(event.targetState, PlayState) && !Std.isOfType(event.targetState, PauseSubState)) state = null;
        onStateChange(event.targetState);
    }

    override function onStateChangeEnd(event:StateChangeScriptEvent) {
        if (Std.isOfType(event.targetState, ChartEditorState)) {
            for (waveform in event.targetState.audioWaveforms) {
                if (waveform.x == 840) {
                    var offset = (Strumline.KEY_COUNT * ChartEditorState.GRID_SIZE) - 160;
                    waveform.x += offset;
                }
                else if (waveform.x == 360) {
                    var offset = -(Strumline.KEY_COUNT * ChartEditorState.GRID_SIZE) + 160;
                    waveform.x += offset;
                }
            }
            event.targetState.buttonSelectOpponent.width = ChartEditorState.GRID_SIZE * Strumline.KEY_COUNT;
            event.targetState.buttonSelectPlayer.width = ChartEditorState.GRID_SIZE * Strumline.KEY_COUNT;
            event.targetState.buttonSelectPlayer.x = event.targetState.buttonSelectOpponent.x + event.targetState.buttonSelectOpponent.width;
            event.targetState.buttonSelectEvent.x = event.targetState.buttonSelectPlayer.x + event.targetState.buttonSelectPlayer.width;
        }
    }

    function setupMultikey() {
        Strumline.KEY_COUNT = 4;

        Strumline.KEY_COUNT = 7;
        ChartEditorState.STRUMLINE_SIZE = Strumline.KEY_COUNT;
        ChartEditorThemeHandler.TOTAL_COLUMN_COUNT = ChartEditorState.STRUMLINE_SIZE * 2 + 1;
        ChartEditorState.NOTE_PREVIEW_X_POS = -(Strumline.KEY_COUNT * ChartEditorState.GRID_SIZE) + 480;
        FNFLegacyImporter.STRUMLINE_SIZE = Strumline.KEY_COUNT;
        Strumline.STRUMLINE_SIZE = Std.int(104 * NOTE_SCALES[Strumline.KEY_COUNT]);
        Strumline.NOTE_SPACING = NOTE_GAPS[Strumline.KEY_COUNT];
        Strumline.DIRECTIONS = [];
        for (i in 0...Strumline.KEY_COUNT) Strumline.DIRECTIONS.push(i);
    }

    override function onSongLoaded(event:SongLoadScriptEvent) {
        if (PlayState.instance == null && Strumline.KEY_COUNT == 4) return;
        state = PlayState.instance;
        playerStrumline = state.playerStrumline;

        var totalKeys = Strumline.KEY_COUNT;
        processExtraNotes(playerStrumline, totalKeys);
        processExtraNotes(state.opponentStrumline, totalKeys);
    }

    override function onCountdownStart(event:CountdownScriptEvent) {
        if (Strumline.KEY_COUNT != 4) initPreciseInputs();
    }

    override function onUpdate(event:UpdateScriptEvent) {
        // Handle keybinds.
        if (state == null || Strumline.KEY_COUNT == 4) return;
        processInputQueue();
    }

    function mapToBaseDirection(extendedDirection):Int {
        return extendedDirection;
    }

    function processInputQueue() {
        if (inputPressQueue.length + inputReleaseQueue.length == 0) return;

        // Ignore inputs during cutscenes.
        if (state.isInCutscene || state.disableKeys) {
            inputPressQueue = [];
            inputReleaseQueue = [];
            return;
        }

        var notesInRange:Array<NoteSprite> = playerStrumline.getNotesMayHit();

        var notesByDirection:Array<Array<NoteSprite>> = [];
        for (i in 0...Strumline.KEY_COUNT) notesByDirection.push([]);

        for (note in notesInRange) notesByDirection[note.direction].push(note);
        while (inputPressQueue.length > 0) {
            var input:PreciseInputEvent = inputPressQueue.shift();
            playerStrumline.pressKey(input.noteDirection);

            // Don't credit or penalize inputs in Bot Play.
            if (state.isBotPlayMode) continue;

            var notesInDirection:Array<NoteSprite> = notesByDirection[input.noteDirection];

            #if FEATURE_GHOST_TAPPING
            if ((!playerStrumline.mayGhostTap()) && notesInDirection.length == 0)
                #else
            if (notesInDirection.length == 0) #end {
                // Pressed a wrong key with no notes nearby.
                // Perform a ghost miss (anti-spam).
                state.ghostNoteMiss(input.noteDirection, notesInRange.length > 0);

                // Play the strumline animation.
                playerStrumline.getByIndex(DIRECTIONS.indexOf(input.noteDirection)).playPress();
                trace("PENALTY Score: " + state.songScore);
            } else if (notesInDirection.length == 0) {
                // Press a key with no penalty.

                // Play the strumline animation.
                playerStrumline.getByIndex(DIRECTIONS.indexOf(input.noteDirection)).playPress();
                trace("NO PENALTY Score: " + state.songScore);
            } else {
                // Choose the first note, deprioritizing low priority notes.
                var targetNote:Null<NoteSprite> = Lambda.find(notesInDirection, note -> !note.lowPriority);
                if (targetNote == null) targetNote = notesInDirection[0];
                if (targetNote == null) continue;

                // Judge and hit the note.
                state.goodNoteHit(targetNote, input);

                notesInDirection.remove(targetNote);

                // Play the strumline animation.
                playerStrumline.getByIndex(DIRECTIONS.indexOf(input.noteDirection)).playConfirm();
            }
        }

        while (inputReleaseQueue.length > 0) {
            var input:PreciseInputEvent = inputReleaseQueue.shift();

            // Play the strumline animation.
            playerStrumline.getByIndex(DIRECTIONS.indexOf(input.noteDirection)).playStatic();
            playerStrumline.releaseKey(input.noteDirection);
        }
    }

    // Inputs
    function initPreciseInputs() {
        var inputManager = PreciseInputManager.instance;

        inputManager.onInputPressed.removeAll();
        inputManager.onInputReleased.removeAll();
        inputManager.onInputPressed.add(onKeyPress);
        inputManager.onInputReleased.add(onKeyRelease);

        initializeCustomKeyMapping(inputManager);
    }

    /**
     * Callback executed when one of the note keys is pressed.
     */
    function onKeyPress(event:PreciseInputEvent) {
        if (!state.isGamePaused) inputPressQueue.push(event);
    }

    /**
     * Callback executed when one of the note keys is released.
     */
    function onKeyRelease(event:PreciseInputEvent) {
        if (!state.isGamePaused) inputReleaseQueue.push(event);
    }

    function initializeCustomKeyMapping(inputManager) {
        var controls = PlayerSettings.player1.controls;

        initializeKeys(inputManager, controls);
    }

    function initializeKeys(inputManager:PreciseInputManager, controls:Controls) {
        inputManager.clearKeys();
        for (noteDirection in DIRECTIONS) {
            var keys = getKeysForDirection(controls, noteDirection);
            for (key in keys) {
                var input = new FlxInput(key);
                inputManager._keyList.push(key);
                inputManager._keyListArray.push(input);
                inputManager._keyListMap.set(key, input);
                inputManager._keyListDir.set(key, noteDirection);
            }
        }
    }

    function getKeysForDirection(controls:Controls, noteDirection:Int) {
        return switch (noteDirection) {
            case 0: controls.getKeysForAction("note_left");
            case 1: controls.getKeysForAction("note_down");
            case 2: controls.getKeysForAction("note_right");
            case 3: controls.getKeysForAction("freeplay_favorite");
            case 4: controls.getKeysForAction("debug_menu");
            case 5: controls.getKeysForAction("note_up");
            case 6: controls.getKeysForAction("freeplay_left");
            case 7: controls.getKeysForAction("freeplay_left");
            case 8: controls.getKeysForAction("freeplay_left");
            case 9: controls.getKeysForAction("freeplay_left");
        };
    }

    // Helper Methods
    function processExtraNotes(strumline:Strumline, totalKeys:Int) {
        var notesArray = strumline.strumlineNotes.members;
        var baseSpacing = 0;
        if (notesArray.length >= 2) {
            baseSpacing = Std.int(notesArray[1].x - notesArray[0].x);
        }

        for (i in 4...totalKeys) {
            if (i < notesArray.length) {
                var note = notesArray[i];
                var prevNote = notesArray[i - 1];
                note.direction = NOTE_DIRECTIONS[totalKeys][i % NOTE_DIRECTIONS.length];
                note.x = prevNote.x + baseSpacing;
                trace("[MK] Processed extra note: Direction = " + note.direction + ", Index = " + i +
                (strumline == playerStrumline ? " (Player)" : " (Opponent)"));
            }
        }
    }

    // Cleanup
    override function onSubStateCloseBegin(event:SubStateScriptEvent) { if (Std.isOfType(event.targetState, PlayState)) state = null; }

    override function onSongEnd(event:ScriptEvent) { state = null; }

    override function onDestroy(event:ScriptEvent) { state = null; }
}