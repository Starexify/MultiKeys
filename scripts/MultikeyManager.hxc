import funkin.modding.module.ScriptedModule;
import funkin.modding.events.ScriptEvent;
import funkin.play.notes.Strumline;
import funkin.play.PlayState;
import funkin.play.notes.StrumlineNote;
import funkin.input.PreciseInputManager;
import funkin.play.notes.NoteSprite;
import funkin.play.notes.SustainTrail;
import funkin.input.Controls;
import funkin.input.Control;
import funkin.PlayerSettings;
import flixel.input.FlxInput;

class MultikeyManager extends ScriptedModule {
    var DIRECTIONS:Array<Int> = [0, 1, 2, 3, 4, 5, 6];
    var KEY_BINDS:Array<Int> = [83, 68, 70, 32, 74, 75, 76];
    var keyPressed:Array<Bool> = [false, false, false, false, false, false, false];

    var state:PlayState;
    var playerStrumline:Strumline;
    var inputPressQueue:Array<PreciseInputEvent> = [];
    var inputReleaseQueue:Array<PreciseInputEvent> = [];

    function new() {
        super("MultikeyManager", 1001);
    }

    override function onSongLoaded(event:SongLoadScriptEvent) {
        if (PlayState.instance == null) return;
        state = PlayState.instance;
        playerStrumline = state.playerStrumline;

        if (Strumline.KEY_COUNT > 4) {
            var totalKeys = Strumline.KEY_COUNT;
            var notesArray = playerStrumline.strumlineNotes.members;
            var baseSpacing = 0;
            if (notesArray.length >= 2) {
                baseSpacing = Std.int(notesArray[1].x - notesArray[0].x);
            }

            for (i in 4...totalKeys) {
                if (i < notesArray.length) {
                    var note = notesArray[i];
                    var prevNote = notesArray[i - 1];
                    note.direction = DIRECTIONS[i % DIRECTIONS.length];
                    note.x = prevNote.x + baseSpacing;

                    trace("[MK] Processed extra note: Direction = " + note.direction + ", Index = " + i);
                }
            }

            initPreciseInputs();
        }
    }


    override function onUpdate(event:UpdateScriptEvent) {
        // Handle keybinds.
        processInputQueue();
    }

    function initPreciseInputs():Void {
        PreciseInputManager.instance.onInputPressed.remove(state.onKeyPress);
        PreciseInputManager.instance.onInputReleased.remove(state.onKeyRelease);
        PreciseInputManager.instance.onInputPressed.add(onKeyPress);
        PreciseInputManager.instance.onInputReleased.add(onKeyRelease);
        initializeCustomKeyMapping();
    }

    function initializeCustomKeyMapping():Void {
        // Clear existing key mappings
        var inputManager = PreciseInputManager.instance;
        var controls = PlayerSettings.player1.controls;
        controls.bindKeys(Control.NOTE_LEFT, controls.getDefaultKeybinds(controls.keyboardScheme, Control.NOTE_LEFT));
        controls.bindKeys(Control.NOTE_DOWN, controls.getDefaultKeybinds(controls.keyboardScheme, Control.NOTE_DOWN));
        controls.bindKeys(Control.NOTE_RIGHT, controls.getDefaultKeybinds(controls.keyboardScheme, Control.NOTE_RIGHT));
        controls.bindKeys(Control.FREEPLAY_FAVORITE, controls.getDefaultKeybinds(controls.keyboardScheme, Control.FREEPLAY_FAVORITE));
        controls.bindKeys(Control.DEBUG_MENU, controls.getDefaultKeybinds(controls.keyboardScheme, Control.DEBUG_MENU));
        controls.bindKeys(Control.NOTE_UP, controls.getDefaultKeybinds(controls.keyboardScheme, Control.NOTE_UP));
        controls.bindKeys(Control.FREEPLAY_LEFT, controls.getDefaultKeybinds(controls.keyboardScheme, Control.FREEPLAY_LEFT));

        initializeKeys(inputManager, controls);
    }

    function initializeKeys(inputManager:PreciseInputManager, controls:Controls):Void {
        inputManager.clearKeys();

        for (noteDirection in DIRECTIONS) {
            var keys = getKeysForDirection(controls, noteDirection);
            for (key in keys) {
                var input = new FlxInput(key);
                inputManager._keyList.push(key);
                inputManager._keyListArray.push(input);
                inputManager._keyListMap.set(key, input);
                inputManager._keyListDir.set(key, noteDirection);
            }
        }
    }

    function getKeysForDirection(controls:Controls, noteDirection:Int) {
        return switch (noteDirection) {
            case 0: controls.getKeysForAction("note_left");
            case 1: controls.getKeysForAction("note_down");
            case 2: controls.getKeysForAction("note_right");
            case 3: controls.getKeysForAction("freeplay_favorite");
            case 4: controls.getKeysForAction("debug_menu");
            case 5: controls.getKeysForAction("note_up");
            case 6: controls.getKeysForAction("freeplay_left");
        };
    }

    function onKeyPress(event:PreciseInputEvent):Void {
        if (state.isGamePaused) return;
        // Do the minimal possible work here.
        inputPressQueue.push(event);
    }

    function onKeyRelease(event:PreciseInputEvent):Void {
        if (state.isGamePaused) return;
        // Do the minimal possible work here.
        inputReleaseQueue.push(event);
    }

    function processInputQueue():Void {
        if (inputPressQueue.length + inputReleaseQueue.length == 0) return;

        // Ignore inputs during cutscenes.
        if (state.isInCutscene || state.disableKeys) {
            inputPressQueue = [];
            inputReleaseQueue = [];
            return;
        }

        var notesInRange:Array<NoteSprite> = playerStrumline.getNotesMayHit();

        var notesByDirection:Array<Array<NoteSprite>> = [];
        for (i in 0...DIRECTIONS.length)
            notesByDirection.push([]);

        for (note in notesInRange)
            notesByDirection[note.direction].push(note);

        while (inputPressQueue.length > 0) {
            var input:PreciseInputEvent = inputPressQueue.shift();
            playerStrumline.pressKey(input.noteDirection);

            // Don't credit or penalize inputs in Bot Play.
            if (state.isBotPlayMode) continue;

            var notesInDirection:Array<NoteSprite> = notesByDirection[input.noteDirection];

            #if FEATURE_GHOST_TAPPING
            if ((!playerStrumline.mayGhostTap()) && notesInDirection.length == 0)
            #else
            if (notesInDirection.length == 0)
                #end {
                // Pressed a wrong key with no notes nearby.
                // Perform a ghost miss (anti-spam).
                state.ghostNoteMiss(input.noteDirection, notesInRange.length > 0);

                // Play the strumline animation.
                playerStrumline.playPress(input.noteDirection);
                trace('PENALTY Score: ${state.songScore}');
            } else if (notesInDirection.length == 0) {
                // Press a key with no penalty.

                // Play the strumline animation.
                playerStrumline.getByIndex(input.noteDirection);
                trace('NO PENALTY Score: ${state.songScore}');
            } else {
                // Choose the first note, deprioritizing low priority notes.
                var targetNote:Null<NoteSprite> = notesInDirection.find((note) -> !note.lowPriority);
                if (targetNote == null) targetNote = notesInDirection[0];
                if (targetNote == null) continue;

                // Judge and hit the note.
                state.goodNoteHit(targetNote, input);

                notesInDirection.remove(targetNote);

                // Play the strumline animation.
                playerStrumline.playConfirm(input.noteDirection);
            }
        }

        while (inputReleaseQueue.length > 0) {
            var input:PreciseInputEvent = inputReleaseQueue.shift();

            // Play the strumline animation.
            playerStrumline.playStatic(input.noteDirection);
            playerStrumline.releaseKey(input.noteDirection);
        }
    }
}