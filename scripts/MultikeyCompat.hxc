import funkin.data.song.importer.FNFLegacyImporter;
import funkin.graphics.FunkinSprite;
import funkin.modding.module.ScriptedModule;
import funkin.modding.events.ScriptEvent;
import funkin.play.notes.Strumline;
import funkin.play.notes.notestyle.NoteStyle;
import funkin.ui.debug.charting.ChartEditorState;
import funkin.ui.debug.charting.components.ChartEditorEventSprite;
import funkin.ui.debug.charting.components.ChartEditorNoteSprite;
import funkin.ui.debug.charting.handlers.ChartEditorThemeHandler;
import funkin.ui.debug.charting.handlers.ChartEditorToolboxHandler;
import funkin.util.Constants;
import funkin.util.FileWriteMode;
import funkin.util.tools.StringTools;

import flixel.FlxG;

import haxe.ui.components.Label;
import haxe.ui.components.NumberStepper;
import haxe.ui.components.VerticalRule;
import haxe.ui.containers.Box;
import haxe.ui.containers.Frame;
import haxe.ui.containers.Grid;
import haxe.ui.containers.HBox;
import haxe.ui.events.UIEvent;

class MultikeyCompat extends ScriptedModule {
    var mkHooks:MultikeyHooks;
    var chartEditor:ChartEditorState;

    var box:Null<Box>;

    var lastKeyCount:Int = 4;
    var passedEvent:ChartEditorEventSprite;

    var addedComponent:Bool;
    var addedKeysComponent:Bool;

    var playbarKeys:Label;

    var DEFAULT_KEY_COUNT:Int = 4;

    function new() {
        super("MultikeyCompat", 1);
        mkHooks = new MultikeyHooks();
    }

    override function onStateChangeEnd(event:StateChangeScriptEvent) {
        if (Std.isOfType(event.targetState, ChartEditorState)) {
            chartEditor = event.targetState;

            // Add Keys to the Playbar
            if (box == null) box = chartEditor.root.findComponent("playbar", Box, false);
            if (!addedKeysComponent && box != null) {
                var hbox = box.findComponents(null, HBox, 1)[2];
                if (hbox != null) {
                    var remainingLabel = hbox.findComponent("playbarSongRemaining", Label, false);
                    if (remainingLabel != null) hbox.removeComponent(remainingLabel);

                    var rule = new VerticalRule();
                    rule.percentHeight = 80;

                    playbarKeys = new Label();
                    playbarKeys.id = "playbarKeys";
                    playbarKeys.styleNames = "playbarStatus";
                    playbarKeys.verticalAlign = "center";
                    playbarKeys.tooltip = "Left Click to Increase Key Count\nRight Click to Decrease Key Count\nCtrl+Click to open Metadata Window";
                    function updateKeysDisplay() playbarKeys.text = "Keys: " + ChartEditorState.STRUMLINE_SIZE;
                    updateKeysDisplay();

                    playbarKeys.onClick = (event:UIEvent) -> {
                        if (chartEditor.pressingControl()) ChartEditorToolboxHandler.setToolboxState(chartEditor, ChartEditorState.CHART_EDITOR_TOOLBOX_METADATA_LAYOUT, true);
                        else { if (ChartEditorState.STRUMLINE_SIZE < 9) {
                            ChartEditorToolboxHandler.refreshToolbox(chartEditor, ChartEditorState.CHART_EDITOR_TOOLBOX_METADATA_LAYOUT);
                            ChartEditorState.STRUMLINE_SIZE++;
                            updateChartEditor(chartEditor, ChartEditorState.STRUMLINE_SIZE);
                            updateKeysDisplay();
                        }}
                    }
                    playbarKeys.onRightClick = (event:UIEvent) -> if (ChartEditorState.STRUMLINE_SIZE > 1) {
                        ChartEditorToolboxHandler.refreshToolbox(chartEditor, ChartEditorState.CHART_EDITOR_TOOLBOX_METADATA_LAYOUT);
                        ChartEditorState.STRUMLINE_SIZE--;
                        updateChartEditor(chartEditor, ChartEditorState.STRUMLINE_SIZE);
                        updateKeysDisplay();
                    }

                    var newRemainingLabel = new Label();
                    newRemainingLabel.id = "playbarSongRemaining";
                    newRemainingLabel.text = "-1:00";
                    newRemainingLabel.styleNames = "playbarDuration";

                    hbox.addComponent(playbarKeys);
                    hbox.addComponent(rule);
                    hbox.addComponent(newRemainingLabel);
                    chartEditor.playbarSongRemaining = newRemainingLabel;
                    addedKeysComponent = true;
                }
            }
            updateChartEditor(chartEditor, DEFAULT_KEY_COUNT);
        } else
            chartEditor = null;
    }

    override function onUpdate(event:UpdateScriptEvent) {
        if (chartEditor != null) {
            //var keyCount = FileUtilSandboxed.readJSONFromPath("assets/data/songs/2hot/2hot-metadata.json")?.keysCount;
            //trace(chartEditor.get_currentSongId());

            // Add Key Count component to the Song Metadata toolbox
            if (!addedComponent && chartEditor.activeToolboxes.exists(ChartEditorState.CHART_EDITOR_TOOLBOX_METADATA_LAYOUT)) {
                var metadataToolbox = chartEditor.activeToolboxes.get(ChartEditorState.CHART_EDITOR_TOOLBOX_METADATA_LAYOUT);
                var frameVariation = metadataToolbox.findComponent("frameVariation", Frame, true);

                if (frameVariation != null) {
                    var grid = frameVariation.findComponent(null, Grid, true);
                    if (grid != null) {
                        var keyCountLabel:Label = new Label();
                        keyCountLabel.text = "Key Count:";
                        keyCountLabel.verticalAlign = "center";
                        keyCountLabel.horizontalAlign = "right";

                        var keyCount:NumberStepper = new NumberStepper();
                        keyCount.id = "keyCount";
                        keyCount.pos = ChartEditorState.STRUMLINE_SIZE;
                        keyCount.min = 1;
                        keyCount.max = 9;
                        keyCount.tooltip = "Set the key count of the song variation.";
                        keyCount.onChange = (event:UIEvent) -> updateChartEditor(chartEditor, event.target.pos);

                        grid.addComponent(keyCountLabel);
                        grid.addComponent(keyCount);

                        metadataToolbox.height += 30;
                        frameVariation.height += 30;
                        addedComponent = true;
                    }
                }
            }

            // Updates the ChartEditor Key Count based on the KeyCountChange Event
            setChartEditorKeyCount(chartEditor);

            for (note in chartEditor.renderedNotes.members) {
                if (note.noteData != null) {
                    if (note.noteData.data <= ChartEditorState.STRUMLINE_SIZE) addNoteStyleAnimations(note, note.noteData.data, note.fetchNoteStyle(note.noteStyle));
                    var dirName:String = note.overrideData != null ? mkHooks.NOTE_COLORS[note.overrideData % ChartEditorState.STRUMLINE_SIZE] : mkHooks.NOTE_COLORS[note.noteData.data % ChartEditorState.STRUMLINE_SIZE];
                    var animationName:String = "tap" + dirName + StringTools.toTitleCase(note.noteStyle);
                    note.animation.play(animationName);
                    //note.updateHitbox();
                    var bruhStyle = note.fetchNoteStyle(note.noteStyle);
                    note.antialiasing = !bruhStyle._data?.assets?.note?.isPixel ?? true;
                }
            }

            if (chartEditor.gridGhostNote.noteData == null) return;

            var dirNam:String = chartEditor.gridGhostNote.overrideData != null ? mkHooks.NOTE_COLORS[chartEditor.gridGhostNote.overrideData % ChartEditorState.STRUMLINE_SIZE] : mkHooks.NOTE_COLORS[chartEditor.gridGhostNote.noteData.data % ChartEditorState.STRUMLINE_SIZE];
            var ghostAnimName:String = "tap" + dirNam + StringTools.toTitleCase(chartEditor.gridGhostNote?.noteStyle);
            chartEditor.gridGhostNote.animation.play(ghostAnimName);
            if (chartEditor.dragTargetNote != null) {
                if (chartEditor.dragTargetNote.noteData.data <= ChartEditorState.STRUMLINE_SIZE) addNoteStyleAnimations(chartEditor.dragTargetNote, chartEditor.dragTargetNote.noteData.data, chartEditor.dragTargetNote.fetchNoteStyle(chartEditor.dragTargetNote.noteStyle));
                var dirName2:String = chartEditor.dragTargetNote.overrideData != null ? mkHooks.NOTE_COLORS[chartEditor.dragTargetNote.overrideData % ChartEditorState.STRUMLINE_SIZE] : mkHooks.NOTE_COLORS[chartEditor.dragTargetNote.noteData.data % ChartEditorState.STRUMLINE_SIZE];
                var dragAnimName:String = "tap" + dirName2 + StringTools.toTitleCase(chartEditor.dragTargetNote.noteStyle);
                chartEditor.dragTargetNote.animation.play(dragAnimName);
            }
            var bruhStyle = chartEditor.gridGhostNote.fetchNoteStyle(chartEditor.gridGhostNote.noteStyle);
            chartEditor.gridGhostNote.antialiasing = !bruhStyle._data?.assets?.note?.isPixel ?? true;

            for (hold in chartEditor.renderedHoldNotes.members) {
                if (hold != null) {
                    hold.loadGraphic(Paths.image("NOTE_hold_assets_" + mkHooks.NOTE_COLORS[mkHooks.MULTIKEY_DIRECTIONS[Strumline.KEY_COUNT][hold.noteData?.data % ChartEditorState.STRUMLINE_SIZE]]));
                    hold.graphicWidth = hold.graphic.width / 8 * hold.zoom;
                    hold.updateColorTransform();
                    hold.updateClipping();
                    hold.updateHitbox();
                }
            }
        }
    }

    function setChartEditorKeyCount(chartEditor:ChartEditorState) {
        for (eventSprite in chartEditor.renderedEvents)
            if (FlxG.overlap(chartEditor.gridPlayhead, eventSprite)) {
                passedEvent = eventSprite;
                break;
            }

        if (passedEvent != null && passedEvent.eventData != null && passedEvent.eventData.eventKind == "KeyCountEvent" && passedEvent.eventData.value != null) {
            var currentKeyCount = passedEvent.eventData.value?.keyCount;
            if (currentKeyCount != lastKeyCount) {
                updateChartEditor(chartEditor, currentKeyCount);
            }
        }
    }

    // Updates the Chart Editor based on a custom Key Count
    function updateChartEditor(chartEditor:ChartEditorState, keyCount:Int) {
        //trace("[MultiKeys] Changing Chart Editor Key Count to: " + keyCount);
        if (playbarKeys != null) playbarKeys.text = "Keys: " + keyCount;
        ChartEditorState.STRUMLINE_SIZE = FNFLegacyImporter.STRUMLINE_SIZE = Strumline.KEY_COUNT = keyCount;
        ChartEditorThemeHandler.TOTAL_COLUMN_COUNT = ChartEditorState.STRUMLINE_SIZE * 2 + 1;
        ChartEditorState.NOTE_PREVIEW_X_POS = -(keyCount * ChartEditorState.GRID_SIZE) + 480;
        ChartEditorThemeHandler.updateGridBitmap(chartEditor);
        chartEditor.gridTiledSprite.x = chartEditor.gridPlayhead.x = chartEditor.buttonSelectOpponent.x = FlxG.width / 2 - ChartEditorState.GRID_SIZE * ChartEditorState.STRUMLINE_SIZE;
        chartEditor.notePreview.x = chartEditor.notePreviewPlayhead.x = chartEditor.notePreviewViewport.x = -(keyCount * ChartEditorState.GRID_SIZE) + 480;
        chartEditor.measureTicks.x = chartEditor.gridTiledSprite.x - ChartEditorState.GRID_SIZE;

        chartEditor.gridTiledSprite.width = chartEditor.gridBitmap.width;
        chartEditor.gridPlayhead.remove(chartEditor.gridPlayhead.members[0]);
        var playheadWidth = ChartEditorState.GRID_SIZE * (ChartEditorState.STRUMLINE_SIZE * 2 + 1) + Std.int(ChartEditorState.GRID_SIZE) * 2;
        var playheadSprite = new FunkinSprite().makeSolidColor(playheadWidth, ChartEditorState.PLAYHEAD_HEIGHT, ChartEditorState.PLAYHEAD_COLOR);
        playheadSprite.x = -ChartEditorState.PLAYHEAD_SCROLL_AREA_WIDTH;
        playheadSprite.y = 0;
        chartEditor.gridPlayhead.add(playheadSprite);

        chartEditor.buttonSelectOpponent.width = chartEditor.buttonSelectPlayer.width = ChartEditorState.GRID_SIZE * keyCount;
        chartEditor.buttonSelectPlayer.x = chartEditor.buttonSelectOpponent.x + chartEditor.buttonSelectOpponent.width;
        chartEditor.buttonSelectEvent.x = chartEditor.buttonSelectPlayer.x + chartEditor.buttonSelectPlayer.width;
        chartEditor.buttonSelectPlayer.findComponent(null, Label, false).wordWrap = chartEditor.buttonSelectOpponent.findComponent(null, Label, false).wordWrap = false;

        chartEditor.renderedNotes.setPosition(chartEditor.gridTiledSprite?.x ?? 0.0, chartEditor.gridTiledSprite?.y ?? 0.0);
        chartEditor.renderedHoldNotes.setPosition(chartEditor.gridTiledSprite?.x ?? 0.0, chartEditor.gridTiledSprite?.y ?? 0.0);
        chartEditor.renderedEvents.setPosition(chartEditor.gridTiledSprite?.x ?? 0.0, chartEditor.gridTiledSprite?.y ?? 0.0);
        chartEditor.renderedSelectionSquares.setPosition(chartEditor.gridTiledSprite?.x ?? 0.0, chartEditor.gridTiledSprite?.y ?? 0.0);

/*        if (chartEditor.gridGhostNote.noteData != null) if (chartEditor.gridGhostNote.noteData.data < ChartEditorState.STRUMLINE_SIZE)
            addNoteStyleAnimations(chartEditor.gridGhostNote, chartEditor.gridGhostNote.noteData.data, chartEditor.gridGhostNote.fetchNoteStyle(chartEditor.gridGhostNote.noteStyle));
        for (note in chartEditor.renderedNotes.members) {
            if (note.noteData == null) return;
            if (note.noteData.data < ChartEditorState.STRUMLINE_SIZE) addNoteStyleAnimations(note, note.noteData.data, note.fetchNoteStyle(note.noteStyle));
        }*/

        if (chartEditor.audioWaveforms.members[0] != null)
            chartEditor.audioWaveforms.members[0].x = chartEditor.healthIconDad.x + (lastKeyCount > keyCount ? chartEditor.healthIconDad.width / 2 : -chartEditor.healthIconDad.width / 2);
        if (chartEditor.audioWaveforms.members[1] != null)
            chartEditor.audioWaveforms.members[1].x = chartEditor.healthIconBF.x - (lastKeyCount > keyCount ? chartEditor.healthIconBF.width / 2 : -chartEditor.healthIconBF.width / 2);

        lastKeyCount = keyCount;
    }

    function addNoteStyleAnimations(note:ChartEditorNoteSprite, dir:Int, noteStyle:NoteStyle):Void {
        if (noteStyle.id != Constants.DEFAULT_NOTE_STYLE) return;
        //var dirName:String = StringTools.toTitleCase(mkHooks.DIRECTION_NAMES[dir]);
        var styleID:String = StringTools.toTitleCase(noteStyle.id);
        var anim = noteStyle.fetchNoteAnimationData(dir);

        //note.animation.addByPrefix("tap" + dirName + styleID, styleID + anim.prefix, anim.frameRate, anim.looped, anim.flipX, anim.flipY);
        note.animation.addByPrefix("tap" + mkHooks.NOTE_COLORS[dir] + styleID, styleID + anim.prefix, anim.frameRate, anim.looped, anim.flipX, anim.flipY);
    }
}