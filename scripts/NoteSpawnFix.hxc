import funkin.Highscore;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ScriptedModule;
import funkin.play.PlayState;
import funkin.play.notes.Strumline;

class NoteSpawnFix extends ScriptedModule {
    var playState(get, never):PlayState;
    function get_playState():PlayState { return PlayState.instance; }

    function new() {
        super("NoteSpawnFix", 1);
    }

    override function onCountdownStart(event:CountdownScriptEvent) {
        if (Strumline.KEY_COUNT != 4) regenNoteData();
    }

    override function onSongEvent(event:SongEventScriptEvent) {
        if (event.eventData.eventKind == "KeyCountEvent") reapplyNoteData();
    }

    override function onUpdate(event:UpdateScriptEvent) {
        if (playState == null || Strumline.KEY_COUNT == 4) return;
        if (playState.needsReset) regenNoteData();
    }

    /**
    * Regens the Note Data with the multikey directions
    */
    function regenNoteData() {
        reapplyNoteData();

        //Highscore.tallies.combo = 0;
        //Highscore.tallies.totalNotes = 0;
        // Highscore.tallies = new Tallies();
    }

    var playerNoteData = [];
    var opponentNoteData = [];
    function reapplyNoteData() {
        playState.playerStrumline.clean();
        playState.opponentStrumline.clean();

        // Reset the notes on each strumline.
        playerNoteData = [];
        opponentNoteData = [];
        var noteData = playState.currentChart.notes;

        for (songNote in noteData) {
            var strumTime:Float = songNote.time;
            if (strumTime < 0) continue; // Skip notes that are before the start time.

            switch (songNote.getStrumlineIndex(Strumline.KEY_COUNT)) {
                case 0: playerNoteData.push(songNote);
                case 1: opponentNoteData.push(songNote);
            }
        }

        playState.playerStrumline.applyNoteData(playerNoteData);
        playState.opponentStrumline.applyNoteData(opponentNoteData);
    }
}