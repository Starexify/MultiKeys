import funkin.modding.events.ScriptEvent;
import funkin.modding.module.ScriptedModule;
import funkin.play.PlayState;
import funkin.play.character.BaseCharacter;
import funkin.play.notes.Strumline;
import funkin.util.tools.StringTools;

class MultikeyNoteHandler extends ScriptedModule {
    var playState(get, never):PlayState;

    function get_playState():PlayState { return PlayState.instance; }

    // In case you want to handle it yourself you can change this variable !
    var disableCharacterAnims = false;

    override function onSongLoaded(event:SongLoadScriptEvent) {
        if (playState == null) return;
        Strumline.NOTE_SPLASH_CAP = 12;
    }

    var bf:BaseCharacter;
    override function onUpdate(event:UpdateScriptEvent) {
        if (playState == null || Strumline.KEY_COUNT == 4) return;
        if (!playState.isGamePaused) {
            if (!disableCharacterAnims && playState.currentStage != null && playState.currentStage.getBoyfriend() != null) {
                bf = playState.currentStage.getBoyfriend();
                if (bf.isSinging()) {
                    for (holdNote in playState.playerStrumline.holdNotes.group.members) {
                        // not doing the standard key holding because it looks weird when working with multiple characters on the same strumline
                        if (holdNote != null && holdNote.alive && holdNote.hitNote && !holdNote.missedNote && holdNote.sustainLength > 0)
                            bf.holdTimer = 0;
                    }
                }
            }
        }
    }

    override function onNoteHit(event:HitNoteScriptEvent) {
        if (event.eventCanceled) return;
        if (playState == null) return;

        var strumIndex = event.note.noteData.getStrumlineIndex(Strumline.KEY_COUNT);
        if (!disableCharacterAnims) {
            var singDir = MultikeyHooks.NOTE_DIRECTIONS[Strumline.KEY_COUNT][event.note.noteData.data];
            switch (strumIndex) {
                case 0:
                    playState.currentStage.getBoyfriend().playSingAnimation(singDir, false);
                    playState.currentStage.getBoyfriend().holdTimer = 0;
                case 1:
                    playState.currentStage.getDad().playSingAnimation(singDir, false);
                    playState.currentStage.getDad().holdTimer = 0;
            }
        }

/*        if (event.note.isHoldNote && event.note.holdNoteSprite != null) {
            if (strumIndex == 0) playNoteHoldCover(state.playerStrumline, event.note.holdNoteSprite);
            else playNoteHoldCover(state.opponentStrumline, event.note.holdNoteSprite);
        }*/
    }

    override function onNoteMiss(event:NoteScriptEvent) {
        if (event.eventCanceled) return;
        if (playState == null || Strumline.KEY_COUNT == 4) return;
        if (!disableCharacterAnims) {
            var strumIndex = event.note.noteData.getStrumlineIndex(Strumline.KEY_COUNT);
            var singDir = MultikeyHooks.NOTE_DIRECTIONS[Strumline.KEY_COUNT][event.note.noteData.data];
            switch (strumIndex) {
                case 0: playState.currentStage.getBoyfriend().playSingAnimation(singDir, true);
                case 1: playState.currentStage.getDad().playSingAnimation(singDir, true);
                case 2:
            }
        }
    }

    override function onNoteGhostMiss(event:GhostMissNoteScriptEvent) {
        if (event.eventCanceled) return;
        if (playState == null || Strumline.KEY_COUNT == 4) return;

        if (!disableCharacterAnims) {
            var singDir = MultikeyHooks.NOTE_DIRECTIONS[Strumline.KEY_COUNT][event.dir];
            playState.currentStage.getBoyfriend().playSingAnimation(singDir, true);
        }
    }
}