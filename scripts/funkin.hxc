import flixel.graphics.frames.FlxFramesCollection;
import funkin.data.animation.AnimationData;
import funkin.data.animation.AnimationDataUtil;
import funkin.play.notes.NoteHoldCover;
import funkin.play.notes.NoteSprite;
import funkin.play.notes.notestyle.ScriptedNoteStyle;
import funkin.play.notes.Strumline;
import funkin.util.tools.StringTools;

class FunkinNoteStyle extends ScriptedNoteStyle {
    function new() {
        super("funkin");
    }

    override function getStrumlineAnimationData(dir) {
        var multiDir = MultikeyHooks.MULTIKEY_DIRECTIONS[Strumline.KEY_COUNT][dir];
        var staticName = "arrow" + MultikeyHooks.DIRECTION_NAMES[multiDir];
        var pressName = MultikeyHooks.NOTE_COLORS[multiDir] + " press";
        var confirmName = MultikeyHooks.NOTE_COLORS[multiDir] + " confirm";

        return [
            AnimationDataUtil.toNamed({prefix: staticName}, "static"),
            AnimationDataUtil.toNamed({prefix: pressName}, "press"),
            AnimationDataUtil.toNamed({prefix: confirmName}, "confirm"),
            AnimationDataUtil.toNamed({prefix: confirmName}, "confirm-hold")
        ];
    }

    override function fetchNoteAnimationData(dir) {
        var arrowName = MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][dir];

        return AnimationDataUtil.toNamed({prefix: arrowName});
    }

    override function buildNoteAnimations(target:NoteSprite) {
        for (colorName in MultikeyHooks.NOTE_COLORS)
            target.animation.addByPrefix(colorName + "Scroll", colorName);
    }

    override function buildHoldCoverFrameForDirection(direction) {
        var holdCoverAssetPath = "holdCover" + StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][direction]);
        var atlas = Paths.getSparrowAtlas(holdCoverAssetPath);
        atlas.parent.persist = true;
        return atlas;
    }

    override function buildHoldCoverAnimations(target:NoteHoldCover) {
        for (direction in 0...Strumline.KEY_COUNT) {
            var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][direction]);
            target.glow.animation.addByPrefix("holdCoverStart" + color, "holdCoverStart" + color, NoteHoldCover.FRAMERATE_DEFAULT, false);
            target.glow.animation.addByPrefix("holdCover" + color, "holdCover" + color, NoteHoldCover.FRAMERATE_DEFAULT);
            target.glow.animation.addByPrefix("holdCoverEnd" + color, "holdCoverEnd" + color, NoteHoldCover.FRAMERATE_DEFAULT, false);
        }
    }

    override public function buildHoldCoverSprite(target:NoteHoldCover) {
        // NoteHoldCover has "glow" and "sparks". Right now it only implements "glow"
        // but "sparks" I believe is meant to be used for the ending of the hold note
        var glowAtlas:Null<FlxFramesCollection> = buildHoldCoverFrames(false);
        if (glowAtlas == null) throw "Could not load spritesheet for note style: " + id;

        target.glow.frames = glowAtlas;

        target.antialiasing = !(_data.assets.holdNoteCover?.isPixel ?? false);
        target.glow.antialiasing = !(_data.assets.holdNoteCover?.isPixel ?? false);
        target.scale.set(getHoldCoverScale(), getHoldCoverScale());
        target.updateHitbox();
        target.glow.updateHitbox();

        buildHoldCoverAnimations(target);
    }

    // Scaling
    function getHoldCoverScale() {
        return (_data.assets.holdNoteCover?.scale * MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT]) ?? fallback?.fetchHoldNoteScale() ?? 1.0;
    }

    override function fetchHoldNoteScale() {
        return super.fetchHoldNoteScale() * MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];
    }

    override function getNoteScale() {
        return super.getNoteScale() * MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];
    }

    override function getStrumlineScale() {
        return super.getStrumlineScale() * MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];
    }
}