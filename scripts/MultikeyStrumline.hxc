import flixel.FlxG;
import flixel.math.FlxCallbackPoint;
import flixel.math.FlxPoint;
import funkin.data.song.SongData;
import funkin.play.notes.NoteDirection;
import funkin.play.notes.NoteHoldCover;
import funkin.play.notes.notekind.NoteKind;
import funkin.play.notes.notekind.NoteKindManager;
import funkin.play.notes.NoteSplash;
import funkin.play.notes.NoteSprite;
import funkin.play.notes.notestyle.NoteStyle;
import funkin.play.notes.ScriptedStrumline;
import funkin.play.notes.Strumline;
import funkin.play.notes.SustainTrail;
import funkin.util.tools.StringTools;
import StringTools as StrTools;

class MultikeyStrumline extends ScriptedStrumline {
    public static var DIRECTIONZ:Array<Int> = [0, 1, 2, 3, 4, 5, 6, 7, 8];
    public static var NOTE_GAPS:Array<Int> = [112, 112, 112, 112, 112, 95, 85, 80, 70, 65];
    public static var SIZE:Int = 104;

    public var directions:Array<MultiNoteDirection> = [];
    public var keyCount:Int;

    public function new(noteStyle:NoteStyle, isPlayer:Bool, keyCount:Int, ?scrollSpeed:Float) {
        super(noteStyle, isPlayer, scrollSpeed);
        this.keyCount = keyCount;
        Strumline.KEY_COUNT = keyCount;
        SIZE = Std.int(104 * MultikeyHooks.NOTE_SCALES[keyCount]);

        createMultikeyNotes();

        background.scale.x = get_width() / 2 + Strumline.BACKGROUND_PAD * 2;
        background.x -= Strumline.BACKGROUND_PAD * MultikeyHooks.NOTE_SCALES[keyCount];
        background.updateHitbox();

        noteHoldCovers.maxSize = keyCount;
    }

    function createMultikeyNotes() {
        for (i in 0...keyCount) {
            directions.push({value: i, keyCount: keyCount});

            var note = strumlineNotes.members[i];
            note.x = directions[i].value * NOTE_GAPS[keyCount];
            note.x += Strumline.INITIAL_OFFSET;
            noteStyle.applyStrumlineOffsets(note);
        }
    }

    override public function playNoteSplash(direction:NoteDirection) {
        if (!showNotesplash) return;
        if (!noteStyle.isNoteSplashEnabled()) return;
        var splash:NoteSplash = this.constructNoteSplash();

        if (splash != null) {
            if (!splash.animation.exists("splash1white")) {
                for (i in 0...MultikeyHooks.NOTE_COLORS.length) {
                    splash.animation.addByPrefix("splash" + MultikeyHooks.NOTE_COLORS[i] + "1", "note impact 1 " + MultikeyHooks.NOTE_COLORS[i] + "0", noteStyle.getSplashFramerate(), false, false, false);
                    splash.animation.addByPrefix("splash" + MultikeyHooks.NOTE_COLORS[i] + "2", "note impact 2 " + MultikeyHooks.NOTE_COLORS[i] + "0", noteStyle.getSplashFramerate(), false, false, false);
                }
            }
            var direction = MultikeyHooks.MULTIKEY_DIRECTIONS[Strumline.KEY_COUNT][direction];
            var variant = FlxG.random.int(1, 2);

            splash.playAnimation("splash" + MultikeyHooks.NOTE_COLORS[direction] + variant);
            if (splash.animation.curAnim == null) return;

            splash.animation.curAnim.frameRate = noteStyle.getSplashFramerate() + FlxG.random.int(-noteStyle.getSplashFramerateVariance(), noteStyle.getSplashFramerateVariance());
            splash.offset.set(splash.width * 0.3, splash.height * 0.3);

            splash.x = this.x;
            splash.x += direction * Strumline.NOTE_SPACING;
            splash.x += noteStyle.getSplashOffsets()[0] * splash.scale.x;

            splash.y = this.y;
            splash.y += noteStyle.getSplashOffsets()[1] * splash.scale.y;
        }
    }

    override public function playNoteHoldCover(holdNote:SustainTrail) {
        if (!showNotesplash) return;
        if (!noteStyle.isHoldNoteCoverEnabled()) return;

        var cover:NoteHoldCover = this.constructNoteHoldCover();
        if (cover != null) {
            cover.holdNote = holdNote;
            holdNote.cover = cover;
            cover.visible = true;

            var dir = holdNote.noteDirection;
            var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][dir]);
            cover.glow.animation.play("holdCoverStart" + color);

            cover.x = this.x;
            cover.x += dir * NOTE_GAPS[Strumline.KEY_COUNT];
            cover.x += SIZE / 2;
            cover.x -= cover.width / 2;
            cover.x += noteStyle.getHoldCoverOffsets()[0] * cover.scale.x;
            cover.x += -12; // hardcoded adjustment, because we are evil.

            cover.y = this.y;
            cover.y += Strumline.INITIAL_OFFSET;
            cover.y += SIZE / 2;
            cover.y += noteStyle.getHoldCoverOffsets()[1] * cover.scale.y;
            cover.y += -96; // hardcoded adjustment, because we are evil.
        }
    }

    override public function updateNotes() {
        super.updateNotes();

        for (holdNote in holdNotes.members) {
            if (holdNote == null || !holdNote.alive) continue;
            if (holdNote.hitNote && holdNote.sustainLength <= 0) {
                if (holdNote.cover != null && isPlayer) {
                    var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][holdNote.noteDirection]);
                    holdNote.cover.glow.animation.play("holdCoverEnd" + color);
                } else if (holdNote.cover != null) {
                    // *lightning* *zap* *crackle*
                    holdNote.cover.visible = false;
                    holdNote.cover.kill();
                }
            }
        }
    }

    override public function constructNoteHoldCover():NoteHoldCover {
        var result:NoteHoldCover = super.constructNoteHoldCover();

        if (result != null) {
            result.glow.animation.onFinish.removeAll();
            result.glow.animation.onFinish.add((animationName:String) -> {
                if (StrTools.startsWith(animationName, "holdCoverStart")) {
                    var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][result.holdNote.noteDirection]);
                    result.glow.animation.play("holdCover" + color);
                }
                if (StrTools.startsWith(animationName, "holdCoverEnd")) {
                    trace(animationName);
                    result.visible = false;
                    result.kill();
                }
            });
        }

        return result;
    }

    override public function buildNoteSprite(note:SongNoteData):NoteSprite {
        var noteSprite:NoteSprite = constructNoteSprite();
        if (noteSprite != null) {
            var noteKind:NoteKind = NoteKindManager.getNoteKind(note.kind);
            var noteKindStyle:NoteStyle = NoteKindManager.getNoteStyle(note.kind, this.noteStyle.id) ?? this.noteStyle;
            noteSprite.setupNoteGraphic(noteKindStyle);

            var trueScale = new FlxPoint(strumlineScale.x, strumlineScale.y);

            noteSprite.scale.x *= trueScale.x;
            noteSprite.scale.y *= trueScale.y;
            noteSprite.updateHitbox();

            noteSprite.direction = note.getDirection(Strumline.KEY_COUNT);
            noteSprite.noteData = note;

            noteSprite.x = this.x;
            noteSprite.x += noteSprite.direction * NOTE_GAPS[Strumline.KEY_COUNT];
            noteSprite.x -= Strumline.NUDGE;
            noteSprite.y = -9999;

            if (noteKind != null) noteSprite.scoreable = noteKind.scoreable;
        }

        return noteSprite;
    }

    override public function buildHoldNoteSprite(note:SongNoteData):SustainTrail {
        var holdNoteSprite:SustainTrail = constructHoldNoteSprite();

        if (holdNoteSprite != null) {
            var noteKindStyle:NoteStyle = NoteKindManager.getNoteStyle(note.kind, this.noteStyle.id);
            if (noteKindStyle == null) noteKindStyle = NoteKindManager.getNoteStyle(note.kind, null);
            if (noteKindStyle == null) noteKindStyle = this.noteStyle;

            holdNoteSprite.loadGraphic(Paths.image("NOTE_hold_assets_" + MultikeyHooks.NOTE_COLORS[MultikeyHooks.MULTIKEY_DIRECTIONS[Strumline.KEY_COUNT][note.getDirection(Strumline.KEY_COUNT)]]));

            holdNoteSprite.parentStrumline = this;
            holdNoteSprite.noteData = note;
            holdNoteSprite.strumTime = note.time;
            holdNoteSprite.noteDirection = note.getDirection(Strumline.KEY_COUNT);
            holdNoteSprite.fullSustainLength = note.length;
            holdNoteSprite.sustainLength = note.length;
            holdNoteSprite.missedNote = false;
            holdNoteSprite.hitNote = false;
            holdNoteSprite.visible = true;
            holdNoteSprite.alpha = 1.0;

            holdNoteSprite.x = this.x;
            holdNoteSprite.x += holdNoteSprite.noteDirection * NOTE_GAPS[Strumline.KEY_COUNT];
            holdNoteSprite.x += SIZE / 2;
            holdNoteSprite.x -= holdNoteSprite.width / 2;
            holdNoteSprite.y = -9999;
        }

        return holdNoteSprite;
    }

    override function get_width():Float {
        if (strumlineScale == null) strumlineScale = new FlxCallbackPoint(strumlineScaleCallback);

        return keyCount * NOTE_GAPS[keyCount] * noteSpacingScale * strumlineScale.x;
    }
}

typedef MultiNoteDirection = {value:Int, keyCount:Int}