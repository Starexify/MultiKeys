import flixel.FlxG;
import flixel.math.FlxCallbackPoint;
import flixel.math.FlxPoint;
import funkin.play.notes.NoteDirection;
import funkin.play.notes.NoteHoldCover;
import funkin.play.notes.notekind.NoteKind;
import funkin.play.notes.notekind.NoteKindManager;
import funkin.play.notes.NoteSplash;
import funkin.play.notes.NoteSprite;
import funkin.play.notes.notestyle.NoteStyle;
import funkin.play.notes.ScriptedStrumline;
import funkin.play.notes.Strumline;
import funkin.play.notes.StrumlineNote;
import funkin.play.notes.SustainTrail;
import funkin.util.tools.StringTools;
import StringTools as StrTools;
import funkin.util.Constants;
import funkin.ui.FullScreenScaleMode;

class MultikeyStrumline extends ScriptedStrumline {
    public static var DIRECTIONZ:Array<Int> = [0, 1, 2, 3, 4, 5, 6, 7, 8];
    public static var NOTE_GAPS:Array<Int> = [112, 112, 112, 112, 112, 95, 85, 80, 70, 65];
    public static var SIZE:Int = 104;
    public static var OFFSET:Float = -0.275 * SIZE;

    public var directions:Array<MultiNoteDirection> = [];
    public var keyCount:Int;

    public function new(noteStyle:NoteStyle, isPlayer:Bool, keyCount:Int, ?scrollSpeed:Float) {
        super(noteStyle, isPlayer, scrollSpeed);
        this.keyCount = keyCount;
        SIZE = Std.int(104 * MultikeyHooks.NOTE_SCALES[keyCount]);
        OFFSET = -0.275 * SIZE;

        createMultikeyNotes();

        updateBackground();

        noteHoldCovers.maxSize = keyCount;
    }

    public function createMultikeyNotes() {
        if (directions.length > 0) directions = [];
        if (strumlineNotes.length > 0) strumlineNotes.clear();
        for (i in 0...keyCount) {
            directions.push({value: i, keyCount: keyCount});

            var child:StrumlineNote = new StrumlineNote(noteStyle, isPlayer, i);
            child.x = directions[i].value * NOTE_GAPS[keyCount];
            child.x += OFFSET;
            child.y = 0;

            noteStyle.applyStrumlineOffsets(child);
            this.strumlineNotes.add(child);
        }
    }

    function refreshNotes(keyCount) {
        this.keyCount = keyCount;

        SIZE = Std.int(104 * MultikeyHooks.NOTE_SCALES[keyCount]);
        OFFSET = -0.275 * SIZE;

        updatePosition();
        if (isPlayer) this.x = (FlxG.width / 2 + Constants.STRUMLINE_X_OFFSET * MultikeyHooks.NOTE_SCALES[keyCount]) + (FullScreenScaleMode.gameCutoutSize.x * 0.5);
        else this.x = Constants.STRUMLINE_X_OFFSET * MultikeyHooks.NOTE_SCALES[keyCount] + FullScreenScaleMode.gameCutoutSize.x * 0.5;
        var xOffset = Constants.STRUMLINE_X_OFFSET * MultikeyHooks.NOTE_SCALES[keyCount];
        this.x -= xOffset;

        if (keyCount > 8 && isPlayer) this.x += 9;

        createMultikeyNotes();

        updateBackground();

        refresh();
    }

    function updatePosition() {
        var baseOffset = Constants.STRUMLINE_X_OFFSET * MultikeyHooks.NOTE_SCALES[keyCount];
        var cutoutOffset = FullScreenScaleMode.gameCutoutSize.x * 0.5;
/*        var centeringOffset:Float = 0;
        trace(keyCount);
        if (keyCount < 4) {
            // Shift right based on how many keys we're missing from 4
            var missingKeys = (4 - keyCount) - 1;
            for (key in missingKeys) {
                centeringOffset += strumlineNotes.members[key].width;
            }
        }
        trace(centeringOffset);*/

        if (isPlayer) {
            this.x = (FlxG.width / 2 + baseOffset) + cutoutOffset + centeringOffset;
            // Additional offset for 9-key layouts to improve visual balance
            if (keyCount > 8) this.x += 9;
        } else this.x = baseOffset + cutoutOffset + centeringOffset;

        this.x -= baseOffset;
    }

    function updateBackground() {
        var padding = Strumline.BACKGROUND_PAD * MultikeyHooks.NOTE_SCALES[keyCount];
        background.scale.x = get_width() / 2 + padding * 2;
        background.x = this.x - padding;
        background.updateHitbox();
    }

    override public function updateNotes() {
        super.updateNotes();

        // Fix hold covers not playing animations
        for (holdNote in holdNotes.members) {
            if (holdNote == null || !holdNote.alive) continue;

            if (holdNote.hitNote && holdNote.sustainLength <= 0) {
                if (holdNote.cover != null && isPlayer) {
                    var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][holdNote.noteDirection]);
                    holdNote.cover.glow.animation.play("holdCoverEnd" + color);
                } else if (holdNote.cover != null) {
                    // *lightning* *zap* *crackle*
                    holdNote.cover.visible = false;
                    holdNote.cover.kill();
                }
            }

/*            if (conductorInUse.songPosition > holdNote.strumTime && holdNote.hitNote) {
                if (!customPositionData) {
                    if (isDownscroll) holdNote.y = this.y - Strumline.INITIAL_OFFSET - holdNote.height + SIZE / 2;
                    else holdNote.y = this.y - Strumline.INITIAL_OFFSET + SIZE / 2;

                    holdNote.y += 20;
                }
            }*/
        }
    }

    public function playMultiNoteSplash(direction:Int) {
        if (!showNotesplash) return;
        if (!noteStyle.isNoteSplashEnabled()) return;

        var splash:NoteSplash = this.constructNoteSplash();
        if (splash != null) {
            var colors = MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT];
            for (color in MultikeyHooks.NOTE_COLORS) {
                splash.animation.addByPrefix("splash" + color + "1", "note impact 1 " + color + "0", noteStyle.getSplashFramerate(), false, false, false);
                splash.animation.addByPrefix("splash" + color + "2", "note impact 2 " + color + "0", noteStyle.getSplashFramerate(), false, false, false);
            }

            var animationAmount:Int = splash.animation.getAnimationList().filter((anim) -> return StrTools.startsWith(anim.name, "splash" + colors[direction])).length - 1;
            var variant = FlxG.random.int(1, animationAmount + 1);

            splash.playAnimation("splash" + colors[direction] + variant);

            if (splash.animation.curAnim == null) return;
            splash.animation.curAnim.frameRate = splash.splashFramerate + FlxG.random.int(-splash.splashFramerateVariance, splash.splashFramerateVariance);
            splash.offset.set(splash.width * 0.3, splash.height * 0.3);

            splash.x = this.x;
            splash.x += direction * NOTE_GAPS[Strumline.KEY_COUNT];
            splash.x += noteStyle.getSplashOffsets()[0] * splash.scale.x;

            splash.y = this.y;
            splash.y += noteStyle.getSplashOffsets()[1] * splash.scale.y;
        }
    }

    override public function playNoteSplash(direction:NoteDirection) {}

    override public function playNoteHoldCover(holdNote:SustainTrail) {
        if (!showNotesplash) return;
        if (!noteStyle.isHoldNoteCoverEnabled()) return;

        var cover:NoteHoldCover = this.constructNoteHoldCover();
        if (cover != null) {
            cover.holdNote = holdNote;
            holdNote.cover = cover;
            cover.visible = true;

            var dir = holdNote.noteDirection;
            var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][dir]);
            cover.glow.animation.play("holdCoverStart" + color);

            cover.x = this.x;
            cover.x += dir * NOTE_GAPS[Strumline.KEY_COUNT];
            cover.x += SIZE / 2;
            cover.x -= cover.width / 2;
            cover.x += noteStyle.getHoldCoverOffsets()[0] * cover.scale.x;
            cover.x += -12; // hardcoded adjustment, because we are evil.

            cover.y = this.y;
            cover.y += SIZE / 2;
            cover.y += noteStyle.getHoldCoverOffsets()[1] * cover.scale.y;
            cover.y += -96; // hardcoded adjustment, because we are evil.
        }
    }

    override public function buildNoteSprite(note:SongNoteData):NoteSprite {
        var noteSprite:NoteSprite = constructNoteSprite();
        if (noteSprite != null) {
            var noteKind:NoteKind = NoteKindManager.getNoteKind(note.kind);
            var noteKindStyle:NoteStyle = NoteKindManager.getNoteStyle(note.kind, this.noteStyle.id) ?? this.noteStyle;
            noteSprite.setupNoteGraphic(noteKindStyle);

            var trueScale = new FlxPoint(strumlineScale.x, strumlineScale.y);

            noteSprite.scale.x *= trueScale.x;
            noteSprite.scale.y *= trueScale.y;
            noteSprite.updateHitbox();

            noteSprite.direction = note.getDirection(Strumline.KEY_COUNT);
            noteSprite.noteData = note;

            noteSprite.x = this.x;
            noteSprite.x += noteSprite.direction * NOTE_GAPS[Strumline.KEY_COUNT];
            noteSprite.x -= Strumline.NUDGE;
            noteSprite.y = -9999;

            if (noteKind != null) noteSprite.scoreable = noteKind.scoreable;
        }

        return noteSprite;
    }

    override public function buildHoldNoteSprite(note:SongNoteData):SustainTrail {
        var holdNoteSprite = super.buildHoldNoteSprite(note);

        holdNoteSprite.loadGraphic(Paths.image("NOTE_hold_assets_" + MultikeyHooks.NOTE_COLORS[MultikeyHooks.MULTIKEY_DIRECTIONS[Strumline.KEY_COUNT][note.getDirection(Strumline.KEY_COUNT)]]));
        holdNoteSprite.updateColorTransform();
        holdNoteSprite.updateClipping();
        holdNoteSprite.updateHitbox();

        holdNoteSprite.noteDirection = note.getDirection(Strumline.KEY_COUNT);

        holdNoteSprite.x = this.x;
        holdNoteSprite.x += holdNoteSprite.noteDirection * NOTE_GAPS[Strumline.KEY_COUNT];
        holdNoteSprite.x += SIZE / 2;
        holdNoteSprite.x -= holdNoteSprite.width / 2;
        holdNoteSprite.yOffset *= MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];

        return holdNoteSprite;
    }

    override public function constructNoteSplash():NoteSplash {
        var splash = super.constructNoteSplash();
        splash.scale.x *= MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];
        splash.scale.y *= MultikeyHooks.NOTE_SCALES[Strumline.KEY_COUNT];
        return splash;
    }

    override public function constructNoteHoldCover():NoteHoldCover {
        var result:NoteHoldCover = super.constructNoteHoldCover();

        if (result != null) {
            result.glow.animation.onFinish.removeAll();
            result.glow.animation.onFinish.add((animationName:String) -> {
                if (StrTools.startsWith(animationName, "holdCoverStart")) {
                    var color = StringTools.toTitleCase(MultikeyHooks.MULTIKEY_COLORS[Strumline.KEY_COUNT][result.holdNote.noteDirection]);
                    result.glow.animation.play("holdCover" + color);
                }
                if (StrTools.startsWith(animationName, "holdCoverEnd")) {
                    result.visible = false;
                    result.kill();
                }
            });
        }

        return result;
    }

    override function get_width():Float {
        if (strumlineScale == null) strumlineScale = new FlxCallbackPoint(strumlineScaleCallback);

        return keyCount * NOTE_GAPS[keyCount] * noteSpacingScale * strumlineScale.x;
    }
}

typedef MultiNoteDirection = {value:Int, keyCount:Int}